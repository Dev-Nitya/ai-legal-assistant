name: Deploy AI Legal Assistant to AWS

on:
  push:
    branches: [master]
    paths:
      - "infrastructure/**"
      - "backend/**"
      - ".github/workflows/**"
  workflow_dispatch:
    inputs:
      force_infrastructure_update:
        description: "Force infrastructure update"
        required: false
        default: false
        type: boolean

env:
  AWS_REGION: us-east-1
  INFRA_STACK: ai-legal-assistant-infra
  SERVICE_STACK: ai-legal-assistant-service
  APPLICATION_NAME: ai-legal-assistant
  IMAGE_TAG: latest

jobs:
  provision-secrets:
    name: Provision secrets to AWS Secrets Manager (only on infra changes)
    runs-on: ubuntu-latest
    outputs:
      provisioned: ${{ steps.provision_result.outcome }}
    steps:
      - name: Checkout (fetch history for diff)
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: Detect infra changes
        id: detect_infra
        run: |
          set -e
          # workflow_dispatch should allow manual run (treat as infra-changed if user triggers)
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "infra_changed=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Detect modified files between HEAD and HEAD^ (push)
          if git diff --name-only HEAD^ HEAD | grep -E '^infrastructure/' > /dev/null; then
            echo "infra_changed=true" >> $GITHUB_OUTPUT
          else
            echo "infra_changed=false" >> $GITHUB_OUTPUT
            echo "No infrastructure changes detected, skipping secrets provisioning."
          fi

      - name: Skip provisioning when no infra change
        if: steps.detect_infra.outputs.infra_changed != 'true'
        run: |
          echo "Skipping secrets provisioning (no infra changes)."
          exit 0

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ env.AWS_REGION }}
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

      - name: Provision secrets (create or update)
        id: provision_result
        env:
          ENVIRONMENT: production
          PREFIX: ai-legal-assistant
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          JWT_SECRET_KEY: ${{ secrets.JWT_SECRET_KEY }}
          DB_USERNAME: ${{ secrets.DB_USERNAME }}
          DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
          DB_HOST: ${{ secrets.DB_HOST }}
          LANGSMITH_API_KEY: ${{ secrets.LANGSMITH_API_KEY }}
          AWS_S3_BUCKET: ${{ secrets.AWS_S3_BUCKET }}
        run: |
          set -euo pipefail

          # Optional secrets: rely on environment/parameter expansion to avoid invalid YAML expressions
          # DB_PORT and DB_NAME default will be applied later if not provided by env

          ENV=${ENVIRONMENT:-production}
          PREFIX=${PREFIX:-ai-legal-assistant}
          echo "Provisioning secrets for environment: $ENV"

          aws_secret_name() {
            echo "${PREFIX}-$1-$ENV"
          }

          create_or_update_secret() {
            name="$1"
            payload="$2"

            if aws secretsmanager describe-secret --secret-id "$name" >/dev/null 2>&1; then
              echo "Updating secret: $name"
              aws secretsmanager put-secret-value --secret-id "$name" --secret-string "$payload" >/dev/null
            else
              echo "Creating secret: $name"
              aws secretsmanager create-secret --name "$name" --secret-string "$payload" --description "Managed by GitHub Actions for ${PREFIX}" >/dev/null
            fi
          }

          # OpenAI API key (store as JSON with api_key for compatibility)
          if [ -n "${OPENAI_API_KEY:-}" ]; then
            payload=$(printf '{"api_key":"%s"}' "$OPENAI_API_KEY")
            create_or_update_secret "$(aws_secret_name openai_api_key)" "$payload"
          else
            echo "OPENAI_API_KEY not provided — skipping"
          fi

          # JWT secret (plain string)
          if [ -n "${JWT_SECRET_KEY:-}" ]; then
            payload=$(printf '%s' "$JWT_SECRET_KEY")
            create_or_update_secret "$(aws_secret_name jwt_secret_key)" "$payload"
          else
            echo "JWT_SECRET_KEY not provided — skipping"
          fi

          # LangSmith (optional)
          if [ -n "${LANGSMITH_API_KEY:-}" ]; then
            payload=$(printf '{"api_key":"%s"}' "$LANGSMITH_API_KEY")
            create_or_update_secret "$(aws_secret_name langsmith_api_key)" "$payload"
          else
            echo "LANGSMITH_API_KEY not provided — skipping"
          fi

          # Database credentials (JSON) — only create if all required values present
          if [ -n "${DB_USERNAME:-}" ] && [ -n "${DB_PASSWORD:-}" ] && [ -n "${DB_HOST:-}" ]; then
            DB_PORT=${DB_PORT:-${DB_PORT:-5432}}
            DB_NAME=${DB_NAME:-ai_legal_assistant}
            payload=$(printf '{"username":"%s","password":"%s","host":"%s","port":"%s","database":"%s"}' \
              "$DB_USERNAME" "$DB_PASSWORD" "$DB_HOST" "$DB_PORT" "$DB_NAME")
            create_or_update_secret "$(aws_secret_name db-credentials)" "$payload"
          else
            echo "Database creds incomplete (DB_USERNAME/DB_PASSWORD/DB_HOST) — skipping DB secret"
          fi

          # Optional: store S3 bucket name (non-sensitive but helpful)
          if [ -n "${AWS_S3_BUCKET:-}" ]; then
            payload=$(printf '%s' "${AWS_S3_BUCKET:-}")
            create_or_update_secret "$(aws_secret_name aws_s3_bucket)" "$payload"
          else
            echo "AWS_S3_BUCKET not provided — skipping"
          fi

          # Optional: app-level AWS creds (only if you want to store them)
          if [ -n "${AWS_ACCESS_KEY_ID:-}" ] && [ -n "${AWS_SECRET_ACCESS_KEY:-}" ]; then
            payload=$(printf '{"aws_access_key_id":"%s","aws_secret_access_key":"%s"}' \
              "${AWS_ACCESS_KEY_ID:-}" "${AWS_SECRET_ACCESS_KEY:-}")
            create_or_update_secret "$(aws_secret_name aws_credentials)" "$payload"
          else
            echo "App AWS credentials not provided — skipping"
          fi

          echo "Secrets provisioning complete."

  prepare:
    name: Deploy infra stack (prepare)
    runs-on: ubuntu-latest
    needs: [provision-secrets]
    outputs:
      infra-deployed: ${{ steps.infra_deploy.outcome }}
      ecr_repo_uri: ${{ steps.infra_outputs.outputs.ecr_repo_uri }}
      alb_dns: ${{ steps.infra_outputs.outputs.alb_dns }}
      app_sg: ${{ steps.infra_outputs.outputs.app_sg }}
      tg_arn: ${{ steps.infra_outputs.outputs.tg_arn }}
      subnet1: ${{ steps.infra_outputs.outputs.subnet1 }}
      subnet2: ${{ steps.infra_outputs.outputs.subnet2 }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ env.AWS_REGION }}
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

      - name: Deploy infra stack (create/update)
        id: infra_deploy
        run: |
          set -e
          echo "Deploying infra stack: $INFRA_STACK"
          aws cloudformation deploy \
            --stack-name $INFRA_STACK \
            --template-file infrastructure/infra-stack.yml \
            --capabilities CAPABILITY_NAMED_IAM \
            --parameter-overrides Environment=production DBPassword="${{ secrets.DB_PASSWORD }}" \
            --region ${{ env.AWS_REGION }}

      - name: Get infra outputs
        id: infra_outputs
        run: |
          set -e
          # from stack outputs
          ECR_URI=$(aws cloudformation describe-stacks --stack-name $INFRA_STACK --query "Stacks[0].Outputs[?OutputKey=='EcrRepoUri'].OutputValue" --output text)
          ALB_DNS=$(aws cloudformation describe-stacks --stack-name $INFRA_STACK --query "Stacks[0].Outputs[?OutputKey=='AlbDNS'].OutputValue" --output text)
          REDIS_ENDPOINT=$(aws cloudformation describe-stacks --stack-name $INFRA_STACK --query "Stacks[0].Outputs[?OutputKey=='RedisEndpoint'].OutputValue" --output text)

          # from stack resources (physical IDs)
          APP_SG=$(aws cloudformation describe-stack-resources --stack-name $INFRA_STACK --logical-resource-id AppSecurityGroup --query "StackResources[0].PhysicalResourceId" --output text)
          TG_ARN=$(aws cloudformation describe-stack-resources --stack-name $INFRA_STACK --logical-resource-id AppTargetGroup --query "StackResources[0].PhysicalResourceId" --output text)
          SUBNET1=$(aws cloudformation describe-stack-resources --stack-name $INFRA_STACK --logical-resource-id PrivateSubnet1 --query "StackResources[0].PhysicalResourceId" --output text)
          SUBNET2=$(aws cloudformation describe-stack-resources --stack-name $INFRA_STACK --logical-resource-id PrivateSubnet2 --query "StackResources[0].PhysicalResourceId" --output text)

          echo "ecr_repo_uri=$ECR_URI" >> $GITHUB_OUTPUT
          echo "alb_dns=$ALB_DNS" >> $GITHUB_OUTPUT
          echo "redis_endpoint=$REDIS_ENDPOINT" >> $GITHUB_OUTPUT
          echo "app_sg=$APP_SG" >> $GITHUB_OUTPUT
          echo "tg_arn=$TG_ARN" >> $GITHUB_OUTPUT
          echo "subnet1=$SUBNET1" >> $GITHUB_OUTPUT
          echo "subnet2=$SUBNET2" >> $GITHUB_OUTPUT

      - name: Persist infra-generated secrets to AWS Secrets Manager
        if: ${{ steps.infra_outputs.outputs.redis_endpoint != '' && steps.infra_outputs.outputs.redis_endpoint != 'None' }}
        run: |
          set -euo pipefail
          ENV=production
          PREFIX=ai-legal-assistant
          REDIS_ENDPOINT="${{ steps.infra_outputs.outputs.redis_endpoint }}"
          SECRET_NAME="${PREFIX}-elasticache_endpoint-${ENV}"

          echo "Writing Redis endpoint to Secrets Manager as: $SECRET_NAME"

          if aws secretsmanager describe-secret --secret-id "$SECRET_NAME" >/dev/null 2>&1; then
            echo "Updating secret: $SECRET_NAME"
            aws secretsmanager put-secret-value --secret-id "$SECRET_NAME" --secret-string "$REDIS_ENDPOINT" >/dev/null
          else
            echo "Creating secret: $SECRET_NAME"
            aws secretsmanager create-secret --name "$SECRET_NAME" --secret-string "$REDIS_ENDPOINT" --description "Managed by GitHub Actions for ${PREFIX}" >/dev/null
          fi

  build-and-push:
    needs: prepare
    runs-on: ubuntu-latest
    outputs:
      image-uri: ${{ steps.push.outputs.image_uri }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ env.AWS_REGION }}
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build Docker image
        run: |
          docker build -t ${{ env.APPLICATION_NAME }}:${{ github.sha }} ./backend
          docker tag ${{ env.APPLICATION_NAME }}:${{ github.sha }} ${{ env.APPLICATION_NAME }}:${{ env.IMAGE_TAG }}

      - name: Ensure ECR repo exists (idempotent)
        run: |
          set -e
          ECR_URI="${{ needs.prepare.outputs.ecr_repo_uri }}"
          if [ -z "$ECR_URI" ] || [ "$ECR_URI" = "None" ]; then
            echo "ECR URI not found in infra outputs — creating repo"
            aws ecr create-repository --repository-name ${{ env.APPLICATION_NAME }} || true
            ECR_URI=$(aws ecr describe-repositories --repository-names ${{ env.APPLICATION_NAME }} --query "repositories[0].repositoryUri" --output text)
          fi
          echo "ECR_URI=$ECR_URI" >> $GITHUB_ENV

      - name: Login to ECR
        run: |
          aws ecr get-login-password --region ${{ env.AWS_REGION }} | docker login --username AWS --password-stdin $ECR_URI

      - name: Tag & Push to ECR
        id: push
        run: |
          set -e
          REPO_URI="$ECR_URI"
          docker tag ${{ env.APPLICATION_NAME }}:${{ env.IMAGE_TAG }} $REPO_URI:${{ env.IMAGE_TAG }}
          docker push $REPO_URI:${{ env.IMAGE_TAG }}
          IMAGE_URI="$REPO_URI:${{ env.IMAGE_TAG }}"
          echo "::set-output name=image_uri::$IMAGE_URI"

  deploy-service:
    needs: [prepare, build-and-push]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ env.AWS_REGION }}
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

      - name: Deploy service stack (TaskDefinition + Service)
        id: deploy_service
        run: |
          set -e
          REPO_IMAGE="${{ needs.build-and-push.outputs.image-uri }}"
          echo "Deploying service stack with image: $REPO_IMAGE"

          # hard fail if TG missing
          if [ -z "${{ needs.prepare.outputs.tg_arn }}" ] || [ "${{ needs.prepare.outputs.tg_arn }}" = "None" ]; then
            echo "ERROR: AlbTargetGroupArn not found from infra stack (AppTargetGroup)."; exit 1
          fi

          aws cloudformation deploy \
            --stack-name ${{ env.SERVICE_STACK }} \
            --template-file infrastructure/service-stack.yml \
            --capabilities CAPABILITY_NAMED_IAM \
            --parameter-overrides \
              Environment=production \
              ClusterName=ai-legal-assistant-cluster \
              ImageUri=$REPO_IMAGE \
              AlbTargetGroupArn=${{ needs.prepare.outputs.tg_arn }} \
              AppSecurityGroupId=${{ needs.prepare.outputs.app_sg }} \
              Subnet1=${{ needs.prepare.outputs.subnet1 }} \
              Subnet2=${{ needs.prepare.outputs.subnet2 }} \
            --region ${{ env.AWS_REGION }}

      - name: Force ECS deployment (safety)
        run: |
          CLUSTER=ai-legal-assistant-cluster
          SERVICE=$(aws ecs list-services --cluster $CLUSTER --query "serviceArns[0]" --output text)
          if [ "$SERVICE" != "None" ] && [ -n "$SERVICE" ]; then
            echo "Forcing new deployment"
            aws ecs update-service --cluster $CLUSTER --service $SERVICE --force-new-deployment || true
          else
            echo "Service not found or just created via CFN"
          fi

  summary:
    needs: [prepare, build-and-push, deploy-service]
    runs-on: ubuntu-latest
    steps:
      - name: Create deployment summary
        run: |
          echo "## Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "- ALB URL: http://${{ needs.prepare.outputs.alb_dns }}" >> $GITHUB_STEP_SUMMARY
          echo "- ECR: ${{ needs.prepare.outputs.ecr_repo_uri }}" >> $GITHUB_STEP_SUMMARY
          echo "- Image: ${{ needs.build-and-push.outputs.image-uri }}" >> $GITHUB_STEP_SUMMARY
